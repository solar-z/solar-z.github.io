<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多点BFS：Leetcode 286. Walls and Gates</title>
      <link href="/2022/05/21/%E5%A4%9A%E7%82%B9BFS%EF%BC%9ALeetcode%20286.%20Walls%20and%20Gates/"/>
      <url>/2022/05/21/%E5%A4%9A%E7%82%B9BFS%EF%BC%9ALeetcode%20286.%20Walls%20and%20Gates/</url>
      
        <content type="html"><![CDATA[<h1>多点BFS：Leetcode 286. Walls and Gates</h1><p>Link：<a href="https://leetcode.cn/problems/walls-and-gates/">286. Walls and Gates</a></p><p>题目要求寻找每一个空房间最近的门，显然使用bfs，由于有多个门，可以使用多点bfs，同时开始搜索。</p><p>由于本题中可以通过当前房间的数字来判断是否已经访问过，所以不需要额外的visit数组，可以节省相当多的空间和时间。</p><p>时间复杂度和空间复杂度均为O(mn)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isGate</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;rooms)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; m &amp;&amp; rooms[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; dir = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wallsAndGates</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;rooms)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = rooms.<span class="built_in">size</span>();</span><br><span class="line">        m = rooms[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; qRoom;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    qRoom.<span class="built_in">emplace</span>(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!qRoom.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = qRoom.<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="type">int</span> y = qRoom.<span class="built_in">front</span>().second;</span><br><span class="line">            qRoom.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> newX = x + dir[k][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newY = y + dir[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isGate</span>(newX, newY, rooms) &amp;&amp; (rooms[newX][newY] &gt; rooms[x][y] + <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    rooms[newX][newY] = rooms[x][y] + <span class="number">1</span>;</span><br><span class="line">                    qRoom.<span class="built_in">emplace</span>(newX, newY);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算几何：1453. 圆形靶内的最大飞镖数量</title>
      <link href="/2022/05/20/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%9A1453.%20%E5%9C%86%E5%BD%A2%E9%9D%B6%E5%86%85%E7%9A%84%E6%9C%80%E5%A4%A7%E9%A3%9E%E9%95%96%E6%95%B0%E9%87%8F/"/>
      <url>/2022/05/20/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%9A1453.%20%E5%9C%86%E5%BD%A2%E9%9D%B6%E5%86%85%E7%9A%84%E6%9C%80%E5%A4%A7%E9%A3%9E%E9%95%96%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1>计算几何：1453. 圆形靶内的最大飞镖数量</h1><p>Link：<a href="https://leetcode.cn/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/">1453. 圆形靶内的最大飞镖数量</a><a href="https://leetcode.cn/problems/walls-and-gates/">https://leetcode.cn/problems/walls-and-gates/</a>)</p><p>题目要求求出指定半径的圆所能覆盖的最多的给定点的个数。</p><p>考虑这样一个问题，如果一个圆能覆盖两个以上的点，我们可以移动这个圆，到有两个点在圆上。移动前后是等价的，那么我们可以利用这两个点的坐标和给出的半径，求出圆心位置。大概有2n(n-1)个圆心。除此之外，要考虑到边界情况，即各个点之间距离太远，以至于给定半径的圆只能覆盖一个点，此时这个点即为圆心。算法需要枚举以上所有的圆心，然后遍历计算覆盖的点数，得出最大值即刻返回。</p><p><img src="https://raw.githubusercontent.com/solar-z/cdn/main/blogImg/202205230017202.png" alt="img"></p><p>时间复杂度为O(n^3)，空间复杂度为0(1)。</p><p>一开始写的代码中，for循环使用了int i:darts这种形式，实际上是使用迭代器实现遍历，然而当复杂度飙升至n^3级别时，使用这种方式会让速度变得非常慢，应改为传统方式遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; darts, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;   </span><br><span class="line">        <span class="type">int</span> n=darts.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="type">double</span> cx,cy;</span><br><span class="line">                <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                    cx=darts[i][<span class="number">0</span>];</span><br><span class="line">                    cy=darts[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">int</span> x1 = darts[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> y1 = darts[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> x2 = darts[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> y2 = darts[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">sqrt</span>((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))&gt;<span class="number">2</span>*r+<span class="number">1e-2</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">double</span> v2x = y2-y1;</span><br><span class="line">                    <span class="type">double</span> v2y = x1-x2;</span><br><span class="line">                    <span class="type">double</span> lenab = <span class="built_in">sqrt</span>(v2x*v2x+v2y*v2y);</span><br><span class="line">                    v2x/=lenab;</span><br><span class="line">                    v2y/=lenab;</span><br><span class="line">                    <span class="type">double</span> lenv2 = <span class="built_in">sqrt</span>(r*r-lenab*lenab/<span class="number">4</span>);</span><br><span class="line">                    v2x*=lenv2;</span><br><span class="line">                    v2y*=lenv2;</span><br><span class="line">                    cx = (x1+x2)/<span class="number">2.0</span>+v2x;</span><br><span class="line">                    cy = (y1+y2)/<span class="number">2.0</span>+v2y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                    <span class="type">double</span> kx = darts[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">double</span> ky = darts[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">sqrt</span>((cx-kx)*(cx-kx)+(cy-ky)*(cy-ky))&lt;=r)&#123;</span><br><span class="line">                        tmp++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;max)&#123;</span><br><span class="line">                    max = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记忆化搜索：Leetcode 140. 单词拆分 II</title>
      <link href="/2022/05/16/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%9ALeetcode%20140.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20II/"/>
      <url>/2022/05/16/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%9ALeetcode%20140.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20II/</url>
      
        <content type="html"><![CDATA[<h1>记忆化搜索：Leetcode 140. 单词拆分 II</h1><p>Link: <a href="https://leetcode.cn/problems/word-break-ii/">140. 单词拆分 II</a><a href="https://leetcode-cn.com/problems/iSwD2y/">https://leetcode-cn.com/problems/iSwD2y/</a>)</p><p>本题如果不要求给出拆分结果，只要求给出能否拆分，那么实际上是一道非常容易的dp。</p><p>本题原则上来讲依然可以用dp解决，但是由于可能会出现完全不可能匹配到的情况，比如下面这个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span></span><br><span class="line">wordDict = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaaaa&quot;</span>,<span class="string">&quot;aaaaaaa&quot;</span>,<span class="string">&quot;aaaaaaaa&quot;</span>,<span class="string">&quot;aaaaaaaaa&quot;</span>,<span class="string">&quot;aaaaaaaaaa&quot;</span>]</span><br></pre></td></tr></table></figure><p>这种情况下，由于字典中不含有字母b，所以实际上不可能匹配，但如果使用dp算法，那么即使已经匹配到b之后了，算法仍然会继续遍历执行。而如果使用记忆化搜索，由于dfs会在第一次递归就深入到分支的最深处，从而可以标记b附近开始的子串为不可匹配，之后再匹配到b附近的时候就可以直接返回而不必继续往底层搜索，使得记忆化搜索可以提前判断出失败。</p><p>换句话说，就是dp会多次碰撞不可匹配子串内部的搜索，但是记忆化搜索一旦发现不可匹配的子串就不会再去碰撞。</p><p>当然dp也有记忆化搜索没有的优点，比如循环写法比递归更快，可以用滚动数组来降低空间复杂度。</p><p>时间/空间复杂度：<em>O</em>(<em>n</em>⋅2^n)</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    unordered_set&lt;string&gt; words;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,vector&lt;string&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        words=<span class="built_in">unordered_set</span>(wordDict.<span class="built_in">begin</span>(),wordDict.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(string &amp; s, <span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">count</span>(index)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index == s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                res[index]=&#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[index]=&#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> end=index;end&lt;s.<span class="built_in">size</span>();++end)&#123;</span><br><span class="line">                string w=s.<span class="built_in">substr</span>(index,end-index+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(words.<span class="built_in">count</span>(w)==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">backtrack</span>(s,end+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(string &amp; str:res[end+<span class="number">1</span>])&#123;</span><br><span class="line">                    res[index].<span class="built_in">push_back</span>(str.<span class="built_in">empty</span>()?w:w+<span class="string">&quot; &quot;</span>+str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bfs：Leetcode 433 最小基因变化</title>
      <link href="/2022/05/08/bfs%EF%BC%9ALeetcode%20433%20%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96/"/>
      <url>/2022/05/08/bfs%EF%BC%9ALeetcode%20433%20%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1>bfs：Leetcode 433 最小基因变化</h1><p>Link: <a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">433. 最小基因变化 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>预处理生成图，降低树的宽度</p><p>Bfs加visited数组防止重复访问</p><p>题目中说start可能不在bank中，但是也可能在，如果把start加入bank中一起预处理的话，需要考虑start已经存在于其中的情况。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string start, string end,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g,<span class="type">int</span> m,<span class="type">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        q.<span class="built_in">push</span>(m<span class="number">-1</span>);</span><br><span class="line">        nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(m,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        visited[m<span class="number">-1</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> i = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="type">int</span> num = nums.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;g[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[g[i][j]]==<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j]==endIndex)&#123;</span><br><span class="line">                    <span class="keyword">return</span> num+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">emplace</span>(g[i][j]);</span><br><span class="line">                nums.<span class="built_in">emplace</span>(num+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMutation</span><span class="params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = bank.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=bank.<span class="built_in">begin</span>();i!=bank.<span class="built_in">end</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*i==start)&#123;</span><br><span class="line">                bank.<span class="built_in">erase</span>(i);</span><br><span class="line">                m--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m++;</span><br><span class="line">        bank.<span class="built_in">emplace_back</span>(start);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="type">int</span> endIndex=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bank[i]==end)&#123;</span><br><span class="line">                endIndex=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(;k&lt;<span class="number">8</span>;++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(bank[i][k]!=bank[j][k])&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(count&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">                    g[i].<span class="built_in">emplace_back</span>(j);</span><br><span class="line">                    g[j].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(endIndex == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>(start,end,g,m,endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> bfs </tag>
            
            <tag> 预处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并+分治：Leetcode 327 区间和的个数</title>
      <link href="/2022/05/08/%E5%BD%92%E5%B9%B6+%E5%88%86%E6%B2%BB%EF%BC%9ALeetcode%20327%20%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2022/05/08/%E5%BD%92%E5%B9%B6+%E5%88%86%E6%B2%BB%EF%BC%9ALeetcode%20327%20%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>归并+分治：Leetcode 327 区间和的个数</h1><p>Link: <a href="https://leetcode-cn.com/problems/count-of-range-sum/">327. 区间和的个数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>题目要求返回范围内的区间和个数，数组为无序，直接求没有思路。</p><p>可转换为另一个问题：区间和一共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>个，但区间和实际上为两个前缀和之差，前缀和一共只有n+1个，原问题转换为，求前缀和之差在范围内的个数。</p><p>此时联想到另一个问题：两个升序数组a、b，其中元素称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">n_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">n_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">n_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">n_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在指定范围内的组合数。这个问题很好解决，因为数组为升序，可以在b上使用滑动窗口，窗口只会向右移动，复杂度为O(n)。</p><p>问题已经基本解决，可求出前缀和数组，对其使用归并排序，将数组排为升序。使用分治求出两个子数组中前缀和之差在指定范围的组合数。然后利用上面所说的滑动窗口算法，求出两个前缀和分别在两个子数组中的组合数（只需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">n_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">n_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，不需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">n_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">n_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，因为前缀和永远是后面的减前面的），加在一起即为这一层归并的返回值。</p><p>之后补充树状数组和线段树解法。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">recurSort</span><span class="params">(vector&lt;<span class="type">long</span>&gt;&amp; prefixes, <span class="type">int</span> lower, <span class="type">int</span> upper, <span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> leftRes = <span class="built_in">recurSort</span>(prefixes,lower,upper,left,mid);</span><br><span class="line">        <span class="type">int</span> rightRes = <span class="built_in">recurSort</span>(prefixes,lower,upper,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="type">int</span> res = leftRes+rightRes;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> r = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i = left;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=mid;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=right&amp;&amp;prefixes[l]&lt;prefixes[i]+lower)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r&lt;=right&amp;&amp;prefixes[r]&lt;=prefixes[i]+upper)&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=r-l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">tmp</span><span class="params">(right-left+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> a=left;</span><br><span class="line">        <span class="type">int</span> b=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a&lt;=mid&amp;&amp;b&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prefixes[a]&lt;prefixes[b])&#123;</span><br><span class="line">                tmp[t]=prefixes[a];</span><br><span class="line">                a++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[t]=prefixes[b];</span><br><span class="line">                b++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=mid)&#123;</span><br><span class="line">            <span class="keyword">while</span>(a&lt;=mid)&#123;</span><br><span class="line">                tmp[t]=prefixes[a];</span><br><span class="line">                a++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(b&lt;=right)&#123;</span><br><span class="line">                tmp[t]=prefixes[b];</span><br><span class="line">                b++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;tmp.<span class="built_in">size</span>();x++)&#123;</span><br><span class="line">            prefixes[left+x]=tmp[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countRangeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> cur=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">long</span>&gt; prefixes&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)&#123;</span><br><span class="line">            cur+=n;</span><br><span class="line">            prefixes.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recurSort</span>(prefixes,lower,upper,<span class="number">0</span>,prefixes.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 归并 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie树：Leetcode 最短的单词编码</title>
      <link href="/2022/05/06/Trie%E6%A0%91%EF%BC%9ALeetcode%20%E6%9C%80%E7%9F%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E7%BC%96%E7%A0%81/"/>
      <url>/2022/05/06/Trie%E6%A0%91%EF%BC%9ALeetcode%20%E6%9C%80%E7%9F%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1>Trie树：Leetcode 最短的单词编码</h1><p>Link: <a href="https://leetcode-cn.com/problems/iSwD2y/">剑指 Offer II 065. 最短的单词编码 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>题目要求计算所有不为其他单词后缀的单词长度之和（加上#）。考虑使用Trie树，将字符串反向插入。</p><p>复杂度：时间O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum{w_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>) 空间O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mrow><mn>26</mn><msub><mi>w</mi><mi>i</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\sum{26w_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">26</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>)</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>指第i个单词的长度，26是字符集大小</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">        TrieNode* children[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> sonNum;</span><br><span class="line">        <span class="built_in">TrieNode</span>()&#123;</span><br><span class="line">            sonNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">                children[i]=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">TrieNode* <span class="title">getSon</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(children[c-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                children[c-<span class="string">&#x27;a&#x27;</span>]=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">                sonNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> children[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        TrieNode* root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        unordered_map&lt;TrieNode*,<span class="type">int</span>&gt; nodeMap;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            TrieNode* cur = root;</span><br><span class="line">            string str = words[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=str.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">                cur = cur-&gt;<span class="built_in">getSon</span>(str[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            nodeMap[cur]=str.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [node,i]: nodeMap)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;sonNum==<span class="number">0</span>)&#123;</span><br><span class="line">                res+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典树 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot配置跨域请求时遇到的小问题</title>
      <link href="/2021/09/15/2021-09-15-springboot%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2021/09/15/2021-09-15-springboot%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>!!!</p><h2 >springboot  跨域请求</h2><p>registration类的allowCredentials函数，参数为Boolean，credential的翻译为证书，但这个函数的实际意义是是否允许前端跨域请求携带cookie（可以理解为在cookie中携带验证信息），只有后端设置为allowCredentials(true)且前端设置为withCredentials: true时，跨域请求才可以使用cookie。</p><p>&nbsp;</p><p>!!!</p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>补档初学c++时的笔记</title>
      <link href="/2021/09/10/2021-09-10-%E8%A1%A5%E6%A1%A3%E5%88%9D%E5%AD%A6c++%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/10/2021-09-10-%E8%A1%A5%E6%A1%A3%E5%88%9D%E5%AD%A6c++%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>传一下当时学c++留的笔记，大概是20年疫情封控的时候写的，反正也没事做。<br>!!!</p><h1 >tips</h1><h2 >visual studio 2017 tips</h2><p>1.在vs2017中提示找不到自己添加的某个文件，可以试试更改附加包含目录，此时注意如果是相对路径，应该是以项目的vcxproj后缀文件为基准的相对路径，输入时候给的提示可能是错误的。</p><h2 >犯过的错误集锦</h2><p>1.字符串字面值是const char*类型，无法自动转换为char*，如果有些函数的参数要求是char*类型会报错</p><p>2.不要用字符串操作函数的返回值初始化对象，在vs中会引起那一行的异常（还没搞懂为什么，先记录下来）</p><p>3.练习链表的时候遇到的问题，如果是想在链表末尾插入节点的话，不能使用如下代码,以下这种代码中的p指针并不是链表最后一个节点的next指针，只是p等于链表最后一个节点的next指针，他们都是null指针，对p使用malloc并不能更改链表</p><pre><code>p=head;//head是指向链表第一个节点的指针while(p!=NULL)&#123;p=p-&gt;next;&#125;p=(struct listnode*)malloc(sizeof(struct listnode));p-&gt;next-&gt;data = num;p-&gt;next-&gt;next = NULL;<p></code></pre></p><p>应该使用以下这种</p><pre><code>p = head;while (p-&gt;next != NULL) &#123;p = p-&gt;next;&#125;p-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));p-&gt;next-&gt;data = num;p-&gt;next-&gt;next = NULL;</code></pre><p>这样就可以真正的更改链表</p><p>如果只是遍历链表而不是要添加节点那么不用这样做。</p><p>4，注意这篇md所有的tip都可能被编译器的优化所影响，建议使用 -fno-elide-constructors 关闭优化</p><h2 >函数返回值的理解</h2><p>函数的返回值其实相当于初始化了一个临时变量,然后把用函数里面return的值初始化<strong>(这可能就是函数返回对象时会调用复制构造函数的原因</strong>),在调用这个函数的语句中,函数名就等价于这个临时变量,在调用语句执行结束之后这个临时变量就要消亡  <strong>[因为是额外声明的临时变量作为返回值,所以如果在调用函数的语句中把函数名放在赋值语句的左边,可以对这个临时变量进行赋值,如果这个函数返回的这个临时变量是引用类型,那么则可以进一步修改函数中用到的全局变量或者对象成员变量]</strong></p><h2 >必须使用初始化列表的情况</h2><p>有三种情况必须需要初始化列表而不能使用赋值语句(在csdn里查到的<a href='https://blog.csdn.net/u014725884/article/details/47004509' target='_blank' class='url'>https://blog.csdn.net/u014725884/article/details/47004509</a>)</p><ol><li>类成员为const类型</li><li>类成员为引用类型</li><li>类成员为没有默认构造函数的类类型</li><li>如果类存在继承关系，派生类必须在其初始化列表中调用基类的构造函数(写下这条的时候还没学过第四条,不能弄清对错)</li></ol><p>&nbsp;</p><h1 >从c到c++</h1><p>&nbsp;</p><h2 >const</h2><p>1,常量在声明的时候就必须初始化,在之后不能改变，常量指针不能赋值给非常量指针</p><p>2,不能通过常量指针和常引用改变所指向或者引用的内容,但是所指向和引用的内容仍然可以以其他方式被修改,</p><p>3,非常量指针和非常引用不能用常量指针和常引用初始化,除非进行强制类型转换.</p><p>4,不能把常量指针和常引用赋值给非常量指针和非常引用(这条的意义大概和上一条一样)</p><h1 >类和对象基础</h1><h2 >构造函数调用顺序</h2><pre><code>#include &lt;iostream&gt;class base&#123;public:base()&#123;std::cout&lt;&lt;&quot;base construct&quot;&lt;&lt;std::endl;&#125;<p>&#125;;<br>class car&#123;<br>public:<br>car()&#123;<br>std::cout&lt;&lt;&quot;car construct&quot;&lt;&lt;std::endl;<br>&#125;</p><p>&#125;;<br>class derive:public base&#123;<br>car b;<br>public:<br>derive()&#123;<br>std::cout&lt;&lt;&quot;derive construct&quot;&lt;&lt;std::endl;<br>&#125;</p><p>&#125;;</p><p>int main()&#123;<br>derive d;</p><pre><code>return 0;</code></pre><p>}<br></code></pre></p><p>结果：</p><pre><code>base constructcar constructderive construct<hr><p>Process exited after 0.04906 seconds with return value 0<br>请按任意键继续. . .<br></code></pre></p><p>说明对于派生类对象d来说，构造函数的调用顺序是：</p><p>d的父类对象-&gt;d的成员对象-&gt;d</p><p>&nbsp;</p><h2 >构造函数</h2><p>假设A是已经定义好的class</p><pre><code>A a(n);a=A(m);</code></pre><p>第一行的语句显然是初始化对象a</p><p>第二行语句的意思是重新调用类A的构造函数并且对a进行赋值。</p><p><strong>以下某些结果在不同编译器中结果可能不同</strong></p><h3 >关于构造函数和析构函数的作用</h3><p>构造函数并不是给对象分配空间,他只是给已经份分配空间的对象进行初始化</p><p>析构函数有不是把对象的存储空间free掉,在对象生命周期结束的时候,系统会自动free这些对象占用的存储空间,析构函数在这之前被调用,做一些工作</p><h3 >关于初始化语句和赋值语句的区别</h3><p>1,complex为类名,c1和c2都是对象;</p><pre><code>complex c1(c2);</code></pre><p>这个是初始化语句</p><pre><code>c1=c2;</code></pre><p>这个是赋值语句</p><pre><code>complex c1=c2;</code></pre><p>这个也是初始化语句(这里容易搞错)</p><h3 >移动构造函数</h3><ul><li>移动构造函数的参数是左值引用，只能接受左值。</li></ul><h3 >复制构造函数</h3><ul><li>复制构造函数的参数是右值引用时，只接受右值，当参数是const左值引用时，既接受左值也接受右值，但若有移动构造函数，则右值优先由移动构造函数接受。</li></ul><p>0.复制构造函数只是构造函数在对象创建时起到复制作用时候的别称（复制构造函数只会在某个对象初始化（也就是创建）的时候调用，使用=的赋值操作不调用复制构造函数，=是直接复制，所以是浅拷贝）</p><p>1,有三种方式会调用复制构造函数;</p><p>第一种,用一个对象初始化一个对象(引用语句不算)</p><p>第二种 对象作为函数参数(是对象作为参数,对象的引用作为参数时不会调用复制构造函数)</p><p>第三种 对象作为函数法返回值,会先把函数里面的return返回的对象赋值给一个临时对象,然后返回这个临时对象(在调用函数的语句种,函数名此时就是一个对象,即刚刚提到的临时对象),在调用函数的整个语句结束之后,临时对象消亡.（可能会被编译器优化所影响 ，使用 -fno-elide-constructors 关闭优化）</p><p>2,复制构造函数的参数一般是引用或者从常引用,,因为直接使用类作为参数会导致复制构造函数的无限递归,但是引用和直接复制不同,引用并不会调用复制构造参数,这就避免了无限递归</p><p>3,复制构造函数结束时,这个复制构造函数的参数变量会消亡,但此时并不会调用析构函数,因为这个消亡的参数变量的类型是类的引用,不是类,所以不会调用析构函数</p><p>4.直接赋值两个对象不会触发复制构造函数（因为不需要创建任何对象或者临时对象，所以不会调用任何构造函数）。只要出现了构造函数的调用，就意味着肯定出现了一个新对象（这个新对象可能并不是我们手动创造的，他可能是用完就消亡的临时对象，这时候临时对象的创建和消亡会触发构造函数和析构函数）。</p><h3 >类型转换构造函数</h3><p>（注意以下说明都可能被编译器自带的优化影响，可以使用 -fno-elide-constructors 关闭优化）</p><p>0.类型转换构造函数只是构造函数起到了类型转换时候的别称。（可能是以下两种情况(A是类名）</p><pre><code class='language-c++' lang='c++'>A a(11);（此时调用有合适参数的构造函数用于把11转换并创建这个对象；</code></pre><p>或者</p><pre><code>A a;(假设A有无参构造函数)a=11;（此时如果有合适的重载=运算符，就会优先调用重载运算符，如果没有的话，就会调用有合适参数的构造函数用于类型转换来创建一个临时对象，然后通过普通的=运算符直接把临时对象赋值给a，然后临时对象消亡（会调用析构函数））</code></pre><p>&nbsp;</p><p>1,如果是以初始化的方式，那么</p><pre><code>A a=11;//这种写法会先以11为参数调用类型转换构造函数生成一个对象，然后再以这个临时对象为参数调用复制构造函数生成对象a，（但是这种写法可能会被编译器优化成A a(11),然后就只调用一次类型转换构造函数直接生成对象a，建议开启-fno-elide-constructors关闭优化。）</code></pre><p>2.如果是在声明对象的语句结束之后,再另有一个赋值语句把其他的类型比如int赋值给对象,那么此时系统就会先寻找有没有重载的赋值运算符可用，如果有就用重载的运算符，如果没有就再看看能不能调用类型转换构造函数来制造一个临时对象,然后以直接赋值的方式把临时对象赋值给等号左边的变量.</p><h3 >析构函数</h3><p>0.析构函数在对象消亡之前调用，不管析构函数是默认还是自定义</p><p>1.在计算析构函数的调用时候要注意到,必须等到某个对象生命周期结束才会调用析构函数,但是new出来的对象,它的生命周期是由用户控制的,如果不去delete这个对象,那么它的生命周期在整个进程一直不会结束,也就是说如果没有delete一个new出来的对象,那么永远不会看到因为这个对象的消亡而调用调用析构函数.</p><p>2.在一个对象生命周期结束的时候，对象的所有成员都会自动消亡（不是通过析构函数实现的，默认析构函数是空的，成员消亡只是因为对象本身的空间释放了），我们自定义的析构函数只需要做这之外的工作就好了（比如delete掉new出来的东西），本身的成员所占用空间（比如用来对象中某个用来指向new出来的空间的指针）的释放不需要我们管，随着对象本身的消亡成员直接就会消亡</p><p>&nbsp;</p><h1 >类和对象提高</h1><h2 >this指针</h2><p>在c++中某些成员函数的参数会被编译器自动添加一个this指针(静态成员函数除外,静态成员函数的形参就是实际看到的个数),this指针指向这个函数作用的对象.,</p><h2 >成员对象和封闭类</h2><p>1.在封闭类进行初始化的时候，会使用这个封闭类的构造函数，这个封闭类的构造函数显然会进一步调用成员对象的构造函数，如果这个封闭类的成员对象的构造函数必须需要传入参数，那么在封闭类的构造函数中必须给出成员对象的构造函数所需要的参数,在这时必须要使用初始化列表,而不能在函数内部赋值,因为任何对象在一开始就必须被初始化(<strong>因为对于没有无参构造函数的成员对象,初始化需要参数</strong>),</p><p>2.封闭类的默认复制构造函数会自动调用成员对象的复制构造函数.</p><h2 >常量对象和常量成员函数</h2><p>1,常量对象上不能调用非常量成员函数(<strong>即非常量成员函数所作用的对象必须是非常量成员函数</strong>)所以如果想使用常量对象的函数,那么这个函数必须有const</p><p>2,常量对象的this指针也是const类型,在返回this指针的时候要注意返回类型要写const,不然编译器会报错</p><h1 >运算符重载</h1><h3 >赋值运算符的重载</h3><p>1.</p><pre><code>Complex a;a=&quot;good luck&quot;;</code></pre><p>这里Complex是类名，第二行的等号会调用赋值运算符重载的函数</p><pre><code>Complex a=“good luck”;</code></pre><p>这里是初始化语句不是赋值语句，这里的等号并不是赋值符号，所以只会调用复制构造函数，如果没有参数为char*的复制构造函数那么就会出错。</p><p>2.如果对赋值运算符没有重载过，在给对象赋值的时候编译器会寻找可用的类型转换构造函数，但是如过对赋值运算符进行了重载，那么编译器将可能既不会寻找可用的类型转换构造函数来适应旧的赋值运算符，也不会寻找可用的类型转换函数来适应重载后的赋值运算符，也就是说在赋值运算符重载之后，对于某一个赋值语句，如果仍然没有可用于的重载函数，编译器将直接报错，而不是去寻找类型转换构造函数来适应赋值运算符（无论是重载前的还是重载之后的）</p><h1 >静态局部变量</h1><h2 >1.静态局部变量与递归</h2><p>函数每次递归都是新开辟的一个内存空间，如果在函数体里声明了普通局部变量，那么每递归一层，这个变量和上一层都已经不是同一个变量了</p><p>但是如果是在函数体里生命的静态局部变量，比如下面这句（假设这句是写在某个函数里）</p><pre><code>static int x=0;</code></pre><p>那么无论递归多少层，这个变量都会一直存在，而且即使在递归中再次执行了这一个语句，也不会重新定义一个新的变量，始终都只有这一个，而且在递归中再次执行到这一个语句的时候，这一句会被直接忽略，即使后面有“x=0”这样的初始化语句，x的值也不会变化，因为这一句属于是初始化语句而不是赋值语句，静态局部变量的第二次初始化被完全忽略了</p><h1 >静态成员变量</h1><p>静态成员变量必须初始化，而且要在类外</p><p>格式是 类型名+类名+：：+变量名（+等号+初始值）；</p><p>不需要在前面再写static</p><h1 >隐藏和覆盖（重写）</h1><p>1,隐藏并不要求函数的参数表相同，只要函数名相同即可隐藏。之前的函数被隐藏之后，在调用函数的时候，编译器看不到之前被隐藏的函数，如果后来的函数参数表不符合，编译器并不会去找之前被隐藏掉的函数，而是会直接报错</p><p>覆盖（重写）即为使用虚函数和多态，要求函数参数表也要相同。</p><p>隐藏和覆盖，都可以通过作用域运算符强制改变搜寻时的作用域，来调用先前的函数。</p><p>隐藏没有多态的特性，覆盖（重写）有多态特性。</p><p>如果使用基类指针或者基类引用来调用成员函数或者成员变量，隐藏不会触发多态，而覆盖（重写）会触发多态。</p><p>下面是示例代码，再往下有devc++运行结果</p><pre><code>#include&lt;iostream&gt;using namespace std;class A&#123;public:void f()&#123;cout&lt;&lt;&quot;f1&quot;&lt;&lt;endl;&#125;virtual void g()&#123;cout&lt;&lt;&quot;g1&quot;&lt;&lt;endl;&#125;&#125;;class B:public A&#123;public:void f(int x)&#123;cout&lt;&lt;&quot;f2&quot;&lt;&lt;endl;&#125;virtual void g()&#123;cout&lt;&lt;&quot;g2&quot;&lt;&lt;endl;&#125;&#125;;int main()&#123;A* a=new B;a-&gt;f();a-&gt;g();return 0;&#125;</code></pre><p>运行结果f1g2</p><hr /><p>Process exited after 0.04111 seconds with return value 0请按任意键继续. . .</p><p>3.在成员函数g()中调用一个成员函数f()时，实际上为this-&gt;f()，所使用的this指针类型为g()所在类的指针类型.</p><h1 >动态内存与智能指针</h1><ul><li>建议使用make_shared和make_unique，不要使用构造函数。</li></ul><h2 >unique_ptr</h2><ul><li>没有复制构造函数，只有移动构造函数（参数是右值引用），所以只能用右值构造，不能用左值构造。</li><li>整个程序中，只有一个unique_ptr能够持有某一个对象，若构造函数试图多次传入同一个地址则报错。</li><li>只能移动构造，所以如果unique_ptr的左值作为vector.push_back的参数，则必须先用std::move转为右值，从而使用push_back的右值重载版本来进行移动构造。如果不加std::move，则会报错，因为进入push_back的左值重载版本后会发现没有复制构造函数。</li></ul><h2 >stl与智能指针（以vector.push_back为例）</h2><ul><li>vector.push_back有const左值引用和右值引用两个重载版本，前者接受左值，后者接受右值。</li><li>若push_back参数为右值，则当vector中存放的变量有noexcept的移动构造函数时，使用移动构造函数。（一部分编译器会对移动构造函数自动检测是否抛出exception，若没有则自动加上noexcept）</li><li>若push_back参数为左值，则使用复制构造函数。</li></ul><h2 >shared_ptr</h2><ul><li>有复制构造函数</li><li>可以有多个ptr持有同一个对象，有计数器，为0自动析构。</li></ul>!!!]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>写java时遇到的http编码问题</title>
      <link href="/2021/09/08/2021-09-08-%E5%86%99java%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84http%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2021/09/08/2021-09-08-%E5%86%99java%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84http%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>!!!</p><p>http标准规定必须是iso8859编码。这种编码每个字符只有一个字节（其实就完全可以当成字节流，因为最终解释成哪一种编码完全由服务器和浏览器决定），无法表示中文，所以为了折中，比如浏览器和服务器之间约定使用utf-8编码(服务器端可以在在java代码中控制，浏览器端在前端代码中控制)，但utf-8每个字符占1-3个字节，其实实际上会把utf-8编码的字符串拆成一个一个字节，然后假装成iso--8859编码，接着会使用iso8859传输http请求，然后再以utf-8解释。</p><pre><code class='language-java' lang='java'>String downloadfile =  new String(filename.getBytes(&quot;UTF-8&quot;),&quot;iso-8859-1&quot;);        // 以下载方式打开文件        headers.setContentDispositionFormData(&quot;attachment&quot;, filename);</code></pre><p>上图：因为java内部对String的存储使用utf16编码，但因为服务器和浏览器约定使用utf-8，所以先拿到utf-8编码的字节数组，事实上这个字节数组就完全可以作为iso8859来传输了，但我们需要将其放入String才能继续使用java，此时可以传入字节数组和编码方式，String内部将会认为bytes数组是以这个编码为标准的。（为什么不能传入其他编码方式？假如你传入的是utf8，那java将可能会认为三个字节为一个字符，以后和另一种编码（比如gbk）的操作系统交互时就会把这三个字节作为一组译成gbk编码，这是完全错误的，所以我们要告诉jvm正确的编码）</p><p>&nbsp;</p><p>为什么需要告诉jvm编码呢？反正最后也是让utf8以iso8859来加入httpheader，而iso8859其实是字节流，并不会影响到内部的字节数组。</p><p>个人认为这可能是因为headers设计成只接受iso8859,并且会将不符合这样编码的参数自动转换为iso8859，比如java的String默认是utf16，所有字符都是两字节，此时两字节的中文字符因为没有对应的就会全部乱码，但两字节的英文字符因为可以转换所以可以正常显示。</p><p>!!!</p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于数据库隔离级别实现的思考</title>
      <link href="/2021/09/02/2021-09-02-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2021/09/02/2021-09-02-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>!!!</p><p>2021.10.15：最近深入了解了数据库隔离性，发现之前这篇笔记中很多内容是错误的，有空重写一个。</p><h1 >数据库隔离级别</h1><h2 >tips：</h2><p>在阅读了一些MySQL文档、技术博客、SQL标准文档之后，个人认为很多数据库所实现的未必是完全符合SQL标准的隔离性级别（老旧的SQL1992标准对MVCC和快照隔离缺乏认识），比如Oracle实际上只有两个隔离级别；MySQL 8.0版本虽然实现了四个级别，但其使用的并非传统的基于锁的实现，而是使用了一部分基于<a href='https://zh.wikipedia.org/wiki/多版本并发控制'>多版本并发控制</a>(MVCC)的快照隔离。</p><p>什么是快照隔离？<a href='https://zh.wikipedia.org/wiki/%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB'>Wikipedia Link</a></p><p>很多重要的<a href='https://zh.wikipedia.org/wiki/数据库管理系统'>数据库管理系统</a>已经采用了快照隔离，，如<a href='https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html'>MySQL</a>。原因是快照隔离比<a href='https://zh.wikipedia.org/wiki/可串行性'>可串行性</a>隔离级别的性能更好，且能避免绝大多数并发异常。快照隔离一般用<a href='https://zh.wikipedia.org/wiki/多版本并发控制'>多版本并发控制</a>(MVCC)实现。 快照隔离避免了ISO SQL-92所列举的并发异常现象，但不是SQL-92定义的无并发异常的<a href='https://zh.wikipedia.org/wiki/可串行化'>可串行化</a>。</p><h2 >SQL1992标准定义</h2><p><a href='https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt'>SQL1992 Link</a></p><p>隔离级别有四种，分别是未提交读READ UNCOMMITTED，提交读READ COMMITTED，可重复读REPEATABLE READ，可串行化SERIALIZABLE。根据不同的隔离级别会出现三种问题，分别是P1脏读Dirty read，P2不可重复读Non-repeatable read，P3幻读Phantom。</p><p>四种隔离级别会出现的问题如下表所示，越高的隔离级别出现的问题越少，SERIALIZABLE可以完全避免三个问题。</p><pre><code>Level__________________P1______P2_______P3________READ UNCOMMITTED       y       y        yREAD COMMITTED         n       y        yREPEATABLE READ        n       n        ySERIALIZABLE           n       n        n</code></pre><h2 >使用锁的实现方法</h2><h3 >未提交读</h3><p>未提交读（READ UNCOMMITTED）是最低的隔离级别。允许“脏读”（dirty reads），事务可以看到其他事务“尚未提交”的修改。这种隔离级别不需要使用锁就可以实现。</p><h3 >提交读：</h3><p>在提交读（READ COMMITTED）级别中，基于锁机制并发控制的 DBMS 需要对选定对象的写锁一直保持到事务结束，但是读锁在 SELECT 操作完成后马上释放（因此“不可重复读”现象可能会发生，见下面描述）。和前一种隔离级别一样，也不要求“范围锁”。</p><h3 >可重复读</h3><p>在可重复读（REPEATBLE READS）隔离级别中，基于锁机制并发控制的 DBMS 需要对选定对象的读锁（read locks）和写锁（write locks）一直保持到事务结束，但不要求“范围锁”（在mysql中叫做gap lock），因此可能会发生“幻影读”。</p><h3 >可串行化</h3><p>在基于锁机制并发控制的 DBMS 实现可串行化，要求在选定对象上的读锁和写锁保持直到事务结束后才能释放。在 SELECT 的查询中使用一个 “WHERE” 子句来描述一个范围时应该获得一个“范围锁”（range-locks）。这种机制可以避免“幻影读”（phantom reads）现象，详见下文。当采用不基于锁的并发控制时不用获取锁。但当系统探测到几个并发事务有“写冲突”的时候，只有其中一个是允许提交的。这种机制的详细描述见“<a href='https://zh.wikipedia.org/wiki/%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB'>快照隔离</a>”。</p><p>以上四段引用自<a href='https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB'>维基百科</a></p><h2 >Mysql 8.0实践：</h2><p>上面的tips已经叙述过，当前的mysql8.0版本结合使用锁和快照两种机制，实现了四种隔离级别。</p><p>mysql 8.0版本已经部分改为使用<a href='https://zh.wikipedia.org/wiki/%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB'>快照隔离</a>，首先说明，快照隔离确实可以避免SQL1992标准定义的几种并发异常现象，但是快照隔离实现的并非SQL1992定义的可串行化（即database system concepts教材中所说的冲突可串行化）。</p><p>由于mysql8.0使用了一部分mvcc实现快照隔离，又使用了一部分锁。所以不能用传统的可串行化来思考和评价它，最好是用那三种异常现象来评价。</p><h3 >Mysql8.0的实现方法：</h3><p>以下部分引用自<a href='https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#:~:text=InnoDB%20offers%20all%20four%20transaction,%2C%20REPEATABLE%20READ%20%2C%20and%20SERIALIZABLE%20.'>Mysql Doc Link</a></p><p>注：以下所说“对索引加锁”，当一个表没有显式建立的索引也没有可以自动建立索引的主键时，使用InnoDB自动为其生成的隐藏聚类索引，什么是隐藏聚类索引？定义：<code>If a table has no PRIMARY KEY or suitable UNIQUE index, InnoDB generates a hidden clustered index named GEN_CLUST_INDEX on a synthetic column that contains row ID values. The rows are ordered by the row ID that InnoDB assigns. The row ID is a 6-byte field that increases monotonically as new rows are inserted. Thus, the rows ordered by the row ID are physically in order of insertion.</code></p><p>首先，在提交读和可重复读两个级别下，将读操作分为<a href='https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html'>Locking Reads</a>和<a href='https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html'>Consistent Nonlocking Reads</a>，并且这两种读操作在不同级别下各自行为不同。</p><p>在其他两个级别下，都是和前两个相比有一些区别又有一些相同点。</p><h4 >Locking Read</h4><p>在提交读和可重复读两个级别下， 指的是<code>SELECT ... FOR UPDATE</code>语句和<code>SELECT ... LOCK IN SHARE MODE</code>（与<code>SELECT ... FOR SHARE</code>同义）语句，可以翻译为显式指定在对应行加共享锁。</p><p>文档中更细节的描述是：</p><p><a href='https://dev.mysql.com/doc/refman/8.0/en/select.html'><code>SELECT ... FOR SHARE</code></a></p><p><code>Sets a shared mode lock on any rows that are read. Other sessions can read the rows, but cannot modify them until your transaction commits. If any of these rows were changed by another transaction that has not yet committed, your query waits until that transaction ends and then uses the latest values.</code></p><p>在阅读这部分和另一篇介绍InnoDB中所有锁的类型的mysql文档：<a href='https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html'>InnoDB Locking</a>后，其实我这里有些疑问，对于mysql中的共享锁和排他锁有以下两种理解方式（个人倾向于第一种，因为这比较符合大多数时候大多数人的理解）：</p><p>第一种理解方式：这种共享锁和排他锁都是传统意义上的共享锁和排他锁，并且mysql中根据不同的隔离级别，实际上在进行locking read和update和delete操作时会自动加上这两种锁中的一个（可能根据不同的隔离级别，这两种锁的作用也可能能不同）。</p><p>第一种理解方式的引用原文：</p><pre><code>Shared and Exclusive LocksInnoDB implements standard row-level locking where there are two types of locks, shared (S) locks and exclusive (X) locks.<p>A shared (S) lock permits the transaction that holds the lock to read a row.</p><p>An exclusive (X) lock permits the transaction that holds the lock to update or delete a row.</p><p>If transaction T1 holds a shared (S) lock on row r, then requests from some distinct transaction T2 for a lock on row r are handled as follows:</p><p>A request by T2 for an S lock can be granted immediately. As a result, both T1 and T2 hold an S lock on r.</p><p>A request by T2 for an X lock cannot be granted immediately.</p><p>If a transaction T1 holds an exclusive (X) lock on row r, a request from some distinct transaction T2 for a lock of either type on r cannot be granted immediately. Instead, transaction T2 has to wait for transaction T1 to release its lock on row r.<br></code></pre></p><pre><code>shared lockA kind of lock that allows other transactions to read the locked object, and to also acquire other shared locks on it, but not to write to it. The opposite of exclusive lock.</code></pre><pre><code>exclusive lockA kind of lock that prevents any other transaction from locking the same row. Depending on the transaction isolation level, this kind of lock might block other transactions from writing to the same row, or might also block other transactions from reading the same row. The default InnoDB isolation level, REPEATABLE READ, enables higher concurrency by allowing transactions to read rows that have exclusive locks, a technique known as consistent read.</code></pre><p>&nbsp;</p><p>第二种理解方式：mysql文档中定义的这种共享锁，不同于传统意义上的与排他锁配合对应的共享锁，这种共享锁只需要自己一个就可以起作用，来阻止其他事务的写操作。锁加上之后，其他事务只能读取被锁住的内容但是无法写入，并且如果想要读取的行已经被其他事务修改过但没有提交，那必须要等到那个事务结束后，当前读操作才能开始。而且，这个锁一旦加上，只有在事务提交或回滚后才会释放。</p><p>在mysql中只有当autocommit关闭时，这种锁才可以使用，因为在mysql中如果开启autocommit，将使得每一条语句都被当作一个事务，一条语句提交一次，即事务已经失去意义了。</p><h4 >Consistent Nonlocking Read</h4><p>与consistent read、nonlocking read等词同义。</p><p>在提交读和可重复读两个级别下，普通select语句（与上面的locking read相反，这种查询不显式指定加锁）会被视为consistent Nonblocking read，mysql会使用快照来实现这种查询语句。</p><h4 >可重复读</h4><p>这是InnoDB引擎的默认隔离级别</p><p>情况一：对于Consistent Read，一个事务中的多次Consistent Read操作，那么第一次读操作将建立一个快照，后续的读操作都会使用这个快照，也就是说其他事务对这个事务完全没有了影响，保证了一致性。</p><p>doc中原话如下：</p><p><code>Suppose that you are running in the default REPEATABLE READ isolation level. When you issue a consistent read (that is, an ordinary SELECTstatement), InnoDB gives your transaction a timepoint according to which your query sees the database. If another transaction deletes a row and commits after your timepoint was assigned, you do not see the row as having been deleted. Inserts and updates are treated similarly.</code></p><p>情况二：而对于locking read和update和delete这几种操作来说，加什么锁取决于对应的条件。</p><p>如果索引和where条件都是唯一的，那innoDB引擎只会在那一条索引上加普通锁，如果是locking read语句，则加的显然是<a href='#locking-read'>上面说的那种共享锁</a>，如果是update和delete那可能加的是排他锁。</p><p>对于其他情况的搜索条件，innoDB引擎会对扫描的索引的一个范围加gap lock，gap lock是一种很特殊的锁，对一个范围起作用，效果是使得这个范围内不可以再插入记录，直到锁被释放。由于这种锁起的是抑制作用，所以多个事务可以持有同一范围上的gap lock。gap lock也分共享的和排他的，个人认为是根据操作是locking read还是update/delete来决定加共享还是排他。</p><p>按照doc的描述，这种级别下consistent read会导致幻读，locking read因为加了gap lock应该是不会产生幻读的。也就是说情况一会幻读，情况二不会。</p><h4 >提交读</h4><p><em>情况一</em>：对于一个事务中的多次Consistent Read操作，每次都会使用一个全新的快照。</p><p><code>With [READ COMMITTED] isolation level, each consistent read within a transaction sets and reads its own fresh snapshot.</code></p><p>个人认为这种所谓的全新快照会获得其他事务已提交的更改，但不会获得未提交的更改。</p><p><em>情况二</em>：对于locking read和update和delete语句，innoDB只对索引记录加普通的共享锁或排他锁，而不是上面说过的那种gap lock（区间锁），所以提交读不能防止幻读。</p><p>按照标准规定，提交读是会出现不可重复读的，显然consistent read如果按照我的推理，确实会出现不可重复读。但对于情况二如果加的锁直到事务结束再释放那确实是可以防止不可重复读的。也就是说情况一会幻读和不可重复读，情况二只会幻读。</p><h4 >未提交读</h4><p><a href='https://dev.mysql.com/doc/refman/8.0/en/select.html'><code>SELECT</code></a> statements are performed in a nonlocking fashion, but a possible earlier version of a row might be used. Thus, using this isolation level, such reads are not consistent. This is also called a <a href='https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_dirty_read'>dirty read</a>. Otherwise, this isolation level works like <a href='https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed'><code>READ COMMITTED</code></a>.</p><p>对于select语句，都不加锁，其他语句和提交读一样。</p><p>因为select语句没有锁，所以会出现全部三种异常现象。</p><h4 >可串行化</h4><p>This level is like <a href='https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read'><code>REPEATABLE READ</code></a>, but <code>InnoDB</code> implicitly converts all plain <a href='https://dev.mysql.com/doc/refman/8.0/en/select.html'><code>SELECT</code></a> statements to <a href='https://dev.mysql.com/doc/refman/8.0/en/select.html'><code>SELECT ... FOR SHARE</code></a> if <a href='https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit'><code>autocommit</code></a> is disabled. If <a href='https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit'><code>autocommit</code></a> is enabled, the <a href='https://dev.mysql.com/doc/refman/8.0/en/select.html'><code>SELECT</code></a> is its own transaction. It therefore is known to be read only and can be serialized if performed as a consistent (nonlocking) read and need not block for other transactions. (To force a plain <a href='https://dev.mysql.com/doc/refman/8.0/en/select.html'><code>SELECT</code></a> to block if other transactions have modified the selected rows, disable <a href='https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit'><code>autocommit</code></a>.)</p><p>如果autocommit关闭，那么在可重复读基础上，隐式把所有查询语句后加上FOR SHARE。</p><p>如果autocommit开启，那么每一条语句都是一个事务，也就没意义了。</p><p>在这种隔离级别下，由于所有的查询语句都加锁，并且直到事务结束才释放，那么直到当前事务结束之前，不可能有其他事务写操作出现在当前事务的读操作之后，也就不可能出现幻读了。</p><p>&nbsp;</p><p>&nbsp;</p>!!!]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springmvc的@modelattribute注解</title>
      <link href="/2021/09/01/2021-09-01-springmvc%E7%9A%84@modelattribute%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/09/01/2021-09-01-springmvc%E7%9A%84@modelattribute%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>!!!</p><h2 >springmvc @ModelAttribute注解</h2><h3 >放在方法前</h3><p>在每个handler方法执行之间，执行这个函数，并且把返回值作为value放入model，对应的key设置为注解的value属性，如果没有这个属性，则设置为返回值类型的小写。</p><h3 >放在方法参数前</h3><p>在执行这个方法之前，寻找model中有没有注解中value属性的key（没有value属性则使用参数类型名的全小写）（显然是被之前的某个有modelattribute注解的方法返回的），如果有则绑定到参数，然后寻找请求中有没有可以注入的对象（比如form表单提交的参数），如果有则注入并绑定model，覆盖之前的值。</p><p>其实这个注解可以通过很多种方式绑定参数，比较复杂，上述的只是常见两种的情况。</p><p>!!!</p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试图理解javascript</title>
      <link href="/2021/08/18/2021-08-18-%E8%AF%95%E5%9B%BE%E7%90%86%E8%A7%A3javascript/"/>
      <url>/2021/08/18/2021-08-18-%E8%AF%95%E5%9B%BE%E7%90%86%E8%A7%A3javascript/</url>
      
        <content type="html"><![CDATA[<p>前端好难<br>!!!</p><h2 >函数对局部变量的捕获</h2><ul><li>在c++中，普通函数不会出现这个问题，lambda函数才会捕获局部变量。如果是值捕获，那么只在lambda定义时捕获一次值，之后便不再改变。如果是引用捕获，那c++会记住那个局部变量的地址，在运行时捕获它的值。（注意不是记住名字，所以即使后面调用的环境中有同名但不同地址的第二个变量，捕获的也还是原来定义时环境下的那个变量）</li><li>在javascript中，所有的函数都可以认为是c++中的lambda，也就是意味着函数本身也是可以用来赋值的变量。js中所有局部变量的捕获都是引用捕获。如果被捕获的局部变量不是this，而是普通变量，那么和c++中一样，都是记住变量的地址然后再运行时捕获它的值。如果被捕获的局部变量名字叫this，那么此时情况变得比较特别，javascript中认为this变量是一种”环境“，代表着函数运行时所处的环境，所以在不同对象中调用同一个函数时，其中的this变量的值会是不同的，具体情况如下：</li></ul><pre><code class='language-javascript' lang='javascript'>      var x=&#123;        b:789342,        fun()&#123;          console.log(this.b);        &#125;      &#125;      var a=&#123;        b:1,        f:x.fun,      &#125;;      var c=&#123;        b:2,        f:x.fun,      &#125;      a.f();      c.f();</code></pre><p>输出结果为1和2。显然a.f()中的this.b取了a中的b成员变量的值，也就是意味着此时的this为a。</p><pre><code class='language-javascript' lang='javascript'>      var b=1;      var fun =function()&#123;        console.log(b);      &#125;;      var a=function(c)&#123;        var b=2;        console.log(&quot;fake&quot;+b);        c();      &#125;;      a(fun);</code></pre><p>输出结果为fake2和1。显然b一直都是fun定义时捕获的b，即使后来定义了同名b也一样。</p><p>!!!</p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于java泛型可变参数的思考</title>
      <link href="/2021/06/23/2021-06-23-%E5%85%B3%E4%BA%8Ejava%E6%B3%9B%E5%9E%8B%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2021/06/23/2021-06-23-%E5%85%B3%E4%BA%8Ejava%E6%B3%9B%E5%9E%8B%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>!!!</p><h2 >泛型</h2><ul><li>多个泛型函数嵌套调用时，第二层开始编译期间无法判断模板参数T的匹配类型，所以没有帮我们加上类型转换语句。</li></ul><h2 >泛型可变参数</h2><pre><code class='language-java' lang='java'>&lt;T&gt; T[] test(T... objs)</code></pre><h3 >泛型可变参数的原理</h3><ul><li><ol><li>若传入多个参数，则新建一个array装入，具体类型由各个参数类型匹配的共同基类决定。</li></ol></li><li><ol start='2' ><li>若传入单个参数，若为普通类型，则新建一个array装入。</li></ol></li><li><ol start='3' ><li>若传入单个参数且为数组类型，则不打包直接传入。</li></ol></li></ul><h3 >可能导致的问题</h3><p>若代码如下所示，则不会有问题，因为pickTwo传入三个String，传入瞬间先打包为String[]，然后由K...接收，由于java泛型使用擦除法实现，所以在jvm看来，实际上pickTwo的参数是Object...，也就是Object[]，此时传入的参数是Object[]类型的引用，指向的是String[]对象，然后调用asArray，此时由于编译期不能确定K的类型，所以T为所以擦除法并不帮我们添加任何类型转换，由于参数只有一个且为数组，所以满足上述情况3，不新建array直接传入。asArray返回一个Object[]的引用类型，但其指向的仍然是一开始新建的String[]。pickTwo返回的也是这样的对象引用，回到main后由于擦除法把K匹配为String，所以帮我们在pickTwo调用后添加了转为String[]的语句，此时由于返回值虽然是Object[]类型的引用，但其实际指向一个String[]对象，所以转换成功，下图中注释部分即为编译器处理后的内容。</p><pre><code class='language-java' lang='java'>public class Main &#123;    public static void main(String[] args) &#123;        var c= pickTwo(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;);//String[] c = (String[])pickTwo(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);    &#125;<pre><code>static &amp;lt;K&amp;gt; K[] pickTwo(K...objs) &#123;    var a=asArray(objs);//K[] a = asArray(objs);    return a;&#125;static &amp;lt;T&amp;gt; T[] asArray(T... objs) &#123;    return objs;&#125;</code></pre><p>}</p><p></code></pre></p><p>若代码如下所示，则会有问题，整体过程和上述大体一样，但调用pickTwo时因为参数是普通参数表，所以传入的k1，k2，k3分别是三个Object引用，指向三个String对象，然后调用asArray，此时满足上述的情况1，需要新建一个数组，但是jvm其实是根据引用类型判断建立的数组类型，而不是根据实际指向对象的类型，所以这时建立的是Object[]引用，指向一个Object[]数组，其中存储了三个Object引用，但指向三个String对象，接下来没有问题，因为jvm执行泛型函数时均把T和K当作Object，最后pickTwo返回后，返回的是一个Object[]引用，指向一个Object[]数组，其中存储了三个Object引用，但指向三个String对象，最后有趣擦除法在pickTwo前面添加了(String[])类型转换语句，但是此时返回的Object[]引用指向的是一个真正的Object[]数组，所以转换失败。抛出异常。</p><pre><code class='language-java' lang='java'>public class Main &#123;    public static void main(String[] args) &#123;        var c= pickTwo(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;);//String[] c = (String[])pickTwo(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);    &#125;<pre><code>static &amp;lt;K&amp;gt; K[] pickTwo(K k1, K k2,K k3) &#123;    var a=asArray(objs);//K[] a = asArray(objs);    return a;&#125;static &amp;lt;T&amp;gt; T[] asArray(T... objs) &#123;    return objs;&#125;</code></pre><p>}</p><p></code></pre></p><h3 >问题原因</h3><p>原因是java一般来讲</p><ul><li>传递的参数若是int这种基础类型， 则参数是新建一个int，是传值。</li><li>传递的参数若是String这种对象，则参数是新建一个引用，是传引用。</li><li>若使用参数表，则是新建一个数组，把参数装进去，然后传递数组对象的引用。</li></ul><p>问题就出在上述第三种情况，当多个的泛型函数嵌套调用时，若某一个函数使用普通参数列表，但他调用的函数使用了可变参数列表，此时无论传入的引用指向的对象的实际类型是什么，jvm只能看到引用的类型，由于jvm把所有泛型参数都当作Object，此时建立的可变参数数组一定是Object[]引用，指向一个Object[]数组,在这之后返回时，某一层由于可以被编译器判断具体类型而加上了类型转换语句，此时这个类型转换就会出错。</p><p>!!!</p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假闲着写的B树</title>
      <link href="/2021/01/27/2021-01-27-%E5%AF%92%E5%81%87%E9%97%B2%E7%9D%80%E5%86%99%E7%9A%84B%E6%A0%91/"/>
      <url>/2021/01/27/2021-01-27-%E5%AF%92%E5%81%87%E9%97%B2%E7%9D%80%E5%86%99%E7%9A%84B%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>!!!</p><ul><li>btree.h</li></ul><pre><code class='language-cpp' lang='cpp'>#pragma once<p>class btree;<br>class btreenode;</p><p>class btreenode &#123;<br>int * keys;<br>int t;<br>btreenode ** sons;<br>int keynum;<br>bool isleaf;<br>public:<br>btreenode(int _t, bool _isleaf); //constructor</p><pre><code>void traverse();btreenode* search(int k);void insertNonFull(int k);//the node must be nonfull when this function is calledvoid splitChild(int i);int getPred(int index);int getSucc(int index);void borrowFromPrev(int index);void borrowFromNext(int index);void merge(int index);void removeFromLeaf(int index);void removeFromNonLeaf(int index);void fill(int index);int findkey(int k);void remove(int k);friend class btree;~btreenode()&#123;delete[] keys;delete[] sons;&#125;</code></pre><p>};<br>class btree {<br>btreenode * root;<br>int t;<br>public:<br>btree(int _t);</p><pre><code>void traverse();btreenode* search(int k);void insert(int k);void remove(int k);</code></pre><p>};<br></code></pre></p><ul><li>btree.cpp</li></ul><pre><code class='language-cpp' lang='cpp'>#include &quot;btree.h&quot;#include &lt;iostream&gt;btreenode::btreenode(int _t, bool _isleaf):t(_t),isleaf(_isleaf)&#123;keys = new int[2 * t - 1];sons= new btreenode*[2 * t];keynum = 0;&#125;<p>void btreenode::traverse()<br>&#123;<br>for (int i = 0; i &lt; keynum; i++) &#123;<br>if(!isleaf) sons[i]-&gt;traverse();<br>std::cout &lt;&lt; &quot; &quot; &lt;&lt; keys[i];<br>&#125;<br>if(!isleaf) sons[keynum]-&gt;traverse();<br>&#125;</p><p>btreenode * btreenode::search(int k)<br>&#123;<br>int i = 0;<br>while (i&lt;keynum&amp;&amp;k&gt;keys[i]) i++;<br>if (i &lt; keynum&amp;&amp;k == keys[i]) return this;<br>if (isleaf) return NULL;<br>return sons[i]-&gt;search(k);<br>&#125;</p><p>void btreenode::insertNonFull(int k)<br>&#123;<br>if (isleaf) &#123;<br>int i = keynum-1;<br>while (i &gt;= 0 &amp;&amp; keys[i] &gt; k) &#123;<br>keys[i + 1] = keys[i];<br>i–;<br>&#125;<br>keys[i + 1] = k;<br>keynum++;<br>&#125;<br>else &#123;<br>int i = keynum - 1;<br>while (i &gt;= 0 &amp;&amp; keys[i] &gt; k) i–;<br>//insert to sons[i+1]<br>if (sons[i + 1]-&gt;keynum == 2 * t - 1) &#123;<br>splitChild(i + 1);<br>if (keys[i + 1] &lt; k) i++;<br>&#125;<br>sons[i + 1]-&gt;insertNonFull(k);<br>&#125;<br>&#125;</p><p>void btreenode::splitChild(int i)<br>&#123;<br>btreenode* y = this-&gt;sons[i];<br>btreenode* z = new btreenode(y-&gt;t, y-&gt;isleaf);</p><pre><code>z-&amp;gt;keynum = y-&amp;gt;t - 1;y-&amp;gt;keynum = y-&amp;gt;t - 1;for (int j = t; j &amp;lt;= 2 * t-2; j++) &#123;z-&amp;gt;keys[j - t] = y-&amp;gt;keys[j];&#125;if (y-&amp;gt;isleaf == false) &#123;for (int j = t; j &amp;lt;= 2 * t - 1; j++) &#123;z-&amp;gt;sons[j - t] = y-&amp;gt;sons[j];&#125;&#125;for (int j = keynum + 1; j &amp;gt;= i + 2; j--) &#123;sons[j] = sons[j - 1];&#125;sons[i + 1] = z;for (int j = keynum; j &amp;gt;= i + 1; j--) &#123;keys[j] = keys[j-1];&#125;keys[i] = y-&amp;gt;keys[t - 1];keynum++;</code></pre><p>}</p><p>int btreenode::getPred(int index)<br>{<br>btreenode* cur = sons[index];<br>while (cur-&gt;isleaf == false)<br>cur = cur-&gt;sons[cur-&gt;keynum];</p><pre><code>return cur-&amp;gt;keys[cur-&amp;gt;keynum - 1];</code></pre><p>}</p><p>int btreenode::getSucc(int index)<br>{<br>btreenode* cur = sons[index + 1];<br>while (cur-&gt;isleaf == false)<br>cur = cur-&gt;sons[0];<br>return cur-&gt;keys[0];<br>}</p><p>void btreenode::borrowFromPrev(int index)//give a key from sons[index-1] to sons[index]<br>{<br>btreenode* child = sons[index];<br>btreenode* sibing = sons[index - 1];<br>for (int i = child-&gt;keynum; i &gt;= 1; i–) {<br>child-&gt;keys[i] = child-&gt;keys[i - 1];<br>}<br>if (child-&gt;isleaf == false)<br>for (int i = child-&gt;keynum + 1; i &gt;= 1; i–)<br>child-&gt;sons[i] = child-&gt;sons[i - 1];<br>child-&gt;keys[0] = keys[index - 1];</p><pre><code>if (child-&amp;gt;isleaf == false)child-&amp;gt;sons[0]=sibing-&amp;gt;sons[sibing-&amp;gt;keynum];keys[index - 1] = sibing-&amp;gt;keys[sibing-&amp;gt;keynum - 1];child-&amp;gt;keynum++;sibing-&amp;gt;keynum--;return;</code></pre><p>}</p><p>void btreenode::borrowFromNext(int index)<br>{<br>btreenode* child = sons[index];<br>btreenode* sibling = sons[index + 1];</p><pre><code>//give the keychild-&amp;gt;keys[child-&amp;gt;keynum] = keys[index];keys[index] = sibling-&amp;gt;keys[0];for (int i = 0; i &amp;lt;= sibling-&amp;gt;keynum - 2; i++)sibling-&amp;gt;keys[i] = sibling-&amp;gt;keys[i + 1];//give the sonsif (child-&amp;gt;isleaf == false) &#123;child-&amp;gt;sons[child-&amp;gt;keynum + 1] = sibling-&amp;gt;sons[0];for (int i = 0; i &amp;lt;= sibling-&amp;gt;keynum - 1; i++)sibling-&amp;gt;sons[i] = sibling-&amp;gt;sons[i + 1];&#125;//change the keynumchild-&amp;gt;keynum++;sibling-&amp;gt;keynum--;return;</code></pre><p>}</p><p>void btreenode::merge(int index)//merge sons[index] with sons[index+1]<br>{<br>btreenode* child = sons[index];<br>btreenode* sibling = sons[index + 1];</p><pre><code>child-&amp;gt;keys[t - 1] = keys[index];for (int i = 0; i &amp;lt;= t-2; i++)child-&amp;gt;keys[i + t] = sibling-&amp;gt;keys[i];if (child-&amp;gt;isleaf == false) &#123;for (int i = 0; i &amp;lt;= t-1; i++)child-&amp;gt;sons[t + i] = sibling-&amp;gt;sons[i];&#125;for (int i = index; i &amp;lt;= keynum - 2; i++)&#123;keys[i] = keys[i + 1];&#125;for (int i = index + 1; i &amp;lt;= keynum - 1; i++) &#123;sons[i] = sons[i + 1];&#125;child-&amp;gt;keynum = 2 * t - 1;keynum--;delete sibling;return;</code></pre><p>}</p><p>void btreenode::removeFromLeaf(int index)<br>{</p><pre><code>for (int i = index; i &amp;lt;= keynum - 2; i++)keys[i] = keys[i + 1];keynum--;return;</code></pre><p>}</p><p>void btreenode::removeFromNonLeaf(int index)<br>{<br>int k = keys[index];//the merge function will change the keys[], so we get it first.</p><pre><code>if (sons[index]-&amp;gt;keynum &amp;gt;= t) &#123;int pred = getPred(index);keys[index] = pred;sons[index]-&amp;gt;remove(pred);&#125;else if (sons[index + 1]-&amp;gt;keynum &amp;gt;= t) &#123;int succ = getSucc(index);keys[index] = succ;sons[index + 1]-&amp;gt;remove(succ);&#125;else &#123;merge(index);sons[index]-&amp;gt;remove(k);&#125;</code></pre><p>}</p><p>void btreenode::fill(int index)<br>{<br>if (index != 0 &amp;&amp; sons[index - 1]-&gt;keynum &gt;= t)<br>borrowFromPrev(index);<br>else if (index != keynum &amp;&amp; sons[index + 1]-&gt;keynum &gt;= t)<br>borrowFromNext(index);<br>else {<br>if (index != keynum) merge(index);<br>else merge(index - 1);<br>}<br>return;<br>}</p><p>int btreenode::findkey(int k)<br>{<br>int index = 0;<br>while (index &lt; keynum&amp;&amp;keys[index] &lt; k) {<br>index++;<br>}<br>return index;<br>}</p><p>void btreenode::remove(int k)<br>{<br>int index = findkey(k);<br>if (index &lt; keynum&amp;&amp;keys[index]==k) {<br>if (isleaf) {<br>removeFromLeaf(index);<br>}<br>else<br>removeFromNonLeaf(index);<br>}<br>else {<br>if (isleaf) {<br>std::cout &lt;&lt; &quot;The key &quot; &lt;&lt; k &lt;&lt; &quot; is noy exist in the tree.\n&quot;;<br>return;<br>}<br>else {<br>if (sons[index]-&gt;keynum &lt; t) fill(index);</p><pre><code>if (index &amp;gt; keynum) sons[index - 1]-&amp;gt;remove(k);else sons[index]-&amp;gt;remove(k);&#125;&#125;</code></pre><p>}</p><p>btree::btree(int _t):t(_t),root(NULL)<br>{<br>}</p><p>void btree::traverse()<br>{<br>if (root) root-&gt;traverse();<br>}</p><p>btreenode * btree::search(int k)<br>{<br>if (root) return root-&gt;search(k);<br>else return NULL;<br>}</p><p>void btree::insert(int k)<br>{<br>if (root == NULL) {<br>root = new btreenode(t, true);<br>root-&gt;keys[0] = k;<br>root-&gt;keynum = 1;<br>}<br>else {<br>if (root-&gt;keynum == 2 * t - 1) {<br>btreenode* s = new btreenode(t, false);<br>s-&gt;sons[0] = root;<br>s-&gt;splitChild(0);<br>root = s;<br>}<br>root-&gt;insertNonFull(k);<br>}<br>}</p><p>void btree::remove(int k)<br>{<br>if (root == NULL) {<br>std::cout &lt;&lt; &quot;the tree is empty\n&quot;;<br>return;<br>}<br>root-&gt;remove(k);</p><pre><code>if (root-&amp;gt;keynum == 0) &#123;btreenode* tmp = root;if (root-&amp;gt;isleaf) root = NULL;else root = root-&amp;gt;sons[0];delete tmp;&#125;return;</code></pre><p>}</p><p></code></pre></p><ul><li>test.cpp</li></ul><pre><code class='language-cpp' lang='cpp'>#include &lt;iostream&gt;#include &quot;btree.h&quot;using namespace std;// Driver program to test my functions int main()&#123;btree t(3); // A B-Tree with minium degree 3 <pre><code>t.insert(1);t.insert(3);t.insert(7);t.insert(10);t.insert(11);t.insert(13);t.insert(14);t.insert(15);t.insert(18);t.insert(16);t.insert(19);t.insert(24);t.insert(25);t.insert(26);t.insert(21);t.insert(4);t.insert(5);t.insert(20);t.insert(22);t.insert(2);t.insert(17);t.insert(12);t.insert(6);cout &amp;lt;&amp;lt; &amp;quot;Traversal of tree constructed is\n&amp;quot;;t.traverse();cout &amp;lt;&amp;lt; endl;t.remove(6);cout &amp;lt;&amp;lt; &amp;quot;Traversal of tree after removing 6\n&amp;quot;;t.traverse();cout &amp;lt;&amp;lt; endl;t.remove(13);cout &amp;lt;&amp;lt; &amp;quot;Traversal of tree after removing 13\n&amp;quot;;t.traverse();cout &amp;lt;&amp;lt; endl;t.remove(7);cout &amp;lt;&amp;lt; &amp;quot;Traversal of tree after removing 7\n&amp;quot;;t.traverse();cout &amp;lt;&amp;lt; endl;t.remove(4);cout &amp;lt;&amp;lt; &amp;quot;Traversal of tree after removing 4\n&amp;quot;;t.traverse();cout &amp;lt;&amp;lt; endl;t.remove(2);cout &amp;lt;&amp;lt; &amp;quot;Traversal of tree after removing 2\n&amp;quot;;t.traverse();cout &amp;lt;&amp;lt; endl;t.remove(16);cout &amp;lt;&amp;lt; &amp;quot;Traversal of tree after removing 16\n&amp;quot;;t.traverse();cout &amp;lt;&amp;lt; endl;return 0;</code></pre><p>}<br></code></pre></p><p>&nbsp;</p>!!!]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> btree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两种外排序相关算法</title>
      <link href="/2020/12/09/2020-12-09-%E4%B8%A4%E7%A7%8D%E5%A4%96%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
      <url>/2020/12/09/2020-12-09-%E4%B8%A4%E7%A7%8D%E5%A4%96%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>!!!</p><ul><li>败者树 模板题 <a href='http://dsalgo.openjudge.cn/extsortexec/2/' target='_blank' class='url'>http://dsalgo.openjudge.cn/extsortexec/2/</a></li></ul><pre><code class='language-cpp' lang='cpp'>#include &lt;iostream&gt;int n,m;int losertree[1000];void adjust(int position)&#123;int s=losertree[position];           int father=position/2;while(father&gt;0)&#123;if(s&gt;losertree[father])&#123;int tmp=losertree[father];losertree[father]=s;s=tmp;<pre><code>&#125;father=father/2;&#125;losertree[0]=s;</code></pre><p>}<br>void inittree(){<br>for(int i=n;i&lt;2*n;i++)<br>adjust(i);<br>}<br>void printtree(){<br>for(int i=0;i&lt;n;i++){<br>std::cout&lt;&lt;losertree[i]&lt;&lt;&quot; &quot;;<br>}<br>std::cout&lt;&lt;std::endl;<br>}<br>int main(){<br>std::cin&gt;&gt;n&gt;&gt;m;<br>for(int i=0;i&lt;n;i++){<br>losertree[i]=0;<br>std::cin&gt;&gt;losertree[n+i];<br>}<br>inittree();<br>printtree();<br>for(int i=0;i&lt;m;i++){<br>int a,b;<br>std::cin&gt;&gt;a&gt;&gt;b;<br>losertree[a+n]=b;<br>adjust(a+n);<br>printtree();<br>}<br>return 0;<br>}<br></code></pre></p><ul><li><p>或许是不完全的置换选择排序 模板题 <a href='http://dsalgo.openjudge.cn/extsortexec/1/' target='_blank' class='url'>http://dsalgo.openjudge.cn/extsortexec/1/</a></p><p>生成第一个顺串，当data用完或者heap空时结束</p><pre><code class='language-cpp' lang='cpp'>#include &lt;iostream&gt;#include &lt;queue&gt;std::queue&lt;int&gt; data;int m,n;int heapsize;void siftdown(int* myheap,int position)&#123;int father=position;int son=father*2+1;int tmp=myheap[father];while(son&lt;heapsize)&#123;if(son+1&lt;heapsize&amp;&amp;myheap[son+1]&lt;myheap[son]) son++;if(tmp&gt;myheap[son])&#123;myheap[father]=myheap[son];father=son;son=son*2+1;&#125;else break;&#125;myheap[father]=tmp;&#125;using std::vector;vector&lt;int&gt; mysort(int * myheap)&#123;vector&lt;int&gt; res;int min;while(!data.empty()&amp;&amp;heapsize!=0)&#123;min=myheap[0];res.push_back(min);int tmp;tmp=data.front();data.pop();if(min&lt;=tmp) myheap[0]=tmp;else&#123;myheap[0]=myheap[heapsize-1];myheap[heapsize-1]=tmp;heapsize--;&#125;siftdown(myheap,0);&#125;return res;&#125;int main()&#123;std::cin&gt;&gt;m&gt;&gt;n;int myheap[n];heapsize=n;for(int i=0;i&lt;m;i++)&#123;int tmp;std::cin&gt;&gt;tmp;data.push(tmp);&#125;for(int i=0;i&lt;n;i++)&#123;int tmp;std::cin&gt;&gt;tmp;myheap[i]=tmp;&#125;std::vector&lt;int&gt; res=mysort(myheap);for(std::vector&lt;int&gt;::iterator it=res.begin();it!=res.end();it++)&#123;std::cout&lt;&lt;*it&lt;&lt;&quot; &quot;;&#125;return 0;&#125;</code></pre><p>&nbsp;</p></li></ul><p>&nbsp;</p><p>!!!</p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> external sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css好难</title>
      <link href="/2020/11/18/2020-11-18-css%E5%A5%BD%E9%9A%BE/"/>
      <url>/2020/11/18/2020-11-18-css%E5%A5%BD%E9%9A%BE/</url>
      
        <content type="html"><![CDATA[<p>!!!</p><h2 >position</h2><ul><li>position relative是相对于正常文件流中这个元素原本的位置进行定位。relative定位的元素，其原本位置仍然会占用页面流的一部分，之后的元素会在那之后定位。</li><li>position absolute是相对于这个元素最近的一个祖先进行定位，该祖先满足：position的值必须是：relative、absolute、fixed、(sticky)，若没有这样的祖先则相对于body进行定位。偏移值由其top、bottom、left、right值确定（而绝对定位的元素若超出其父元素的边界，要想将溢出的部分隐藏，则，想隐藏在哪个祖先里，该祖先必须同时设置position:relative/absolute/fixed和overflow:hidden的值）。absolute定位的元素，将不会占用页面流。</li></ul><h2 >width height</h2><ul><li>width height若使用百分比，是相对于这个元素最近的一个祖先，该祖先满足：position的值必须是：relative、absolute、fixed，(sticky)。若没有这样的祖先则相对于body</li></ul><p>!!!</p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些简单算法模板</title>
      <link href="/2020/10/29/2020-10-29-%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/10/29/2020-10-29-%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>!!!</p><ul><li>bellman ford 模板题 poj3259</li></ul><pre><code class='language-cpp' lang='cpp'>#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;int dis[600];struct edge&#123;    int v,to,w;    edge(int _v,int _to,int _w):v(_v),to(_to),w(_w)&#123;&#125;    edge()&#123;&#125;;&#125;;struct edge myedges[5300];int cnt=1;int vnum;void readedge()&#123;    int v,to,w;    std::cin&gt;&gt;v&gt;&gt;to&gt;&gt;w;    myedges[cnt]=edge(v,to,-w);    cnt++;&#125;void readbiegde()&#123;    int v,to,w;    std::cin&gt;&gt;v&gt;&gt;to&gt;&gt;w;    myedges[cnt]=edge(v,to,w);    cnt++;    myedges[cnt]=edge(to,v,w);    cnt++;&#125;int bellmanford()&#123;    for(int j=1;j&lt;vnum;j++)&#123;        for(int i=1;i&lt;=cnt;i++)&#123;            if(dis[myedges[i].to]&gt;dis[myedges[i].v]+myedges[i].w)                dis[myedges[i].to]=dis[myedges[i].v]+myedges[i].w;        &#125;    &#125;    for(int i=1;i&lt;=cnt;i++)&#123;            if(dis[myedges[i].to]&gt;dis[myedges[i].v]+myedges[i].w) return 0;    &#125;    return 1;&#125;int main()&#123;    int f;    std::cin&gt;&gt;f;    for(int i=0;i&lt;f;i++)&#123;        int n,m,w;        std::cin&gt;&gt;n&gt;&gt;m&gt;&gt;w;        cnt=1;        vnum=n;        memset(dis,0x3f,sizeof(dis));        dis[1]=0;        for(int j=0;j&lt;m;j++)&#123;            readbiegde();        &#125;        for(int j=0;j&lt;w;j++)&#123;            readedge();        &#125;        cnt--;        int flag;        flag=bellmanford();        if(!flag) std::cout&lt;&lt;&quot;YES&quot;&lt;&lt;std::endl;        else&#123;            std::cout&lt;&lt;&quot;NO&quot;&lt;&lt;std::endl;        &#125;    &#125;<pre><code>return 0;</code></pre><p>}<br></code></pre></p><ul><li>Edmond Karp 模板题 hdu1532</li></ul><pre><code class='language-cpp' lang='cpp'>#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;int n;int m;int edge[205][205];int pre[205];int vis[205];bool bfs()&#123;    std::queue&lt;int&gt; Q;    Q.push(1);    vis[1]=1;    int u;    while(!Q.empty())&#123;        u=Q.front();        Q.pop();        for(int i=1;i&lt;=n;i++)&#123;            if(edge[u][i]&amp;&amp;!vis[i])&#123;                vis[i]=1;                pre[i]=u;                if(i==n) return true;                Q.push(i);            &#125;        &#125;    &#125;    return false;&#125;int ek()&#123;    int sum=0;    memset(vis,0,sizeof(vis));    for(int i=0;i&lt;205;i++) pre[i]=-1;    while(bfs())&#123;        int flow=0x3f3f3f3f;        int u,pr;        u=n;        pr=pre[u];        while(pr!=-1)&#123;            if(flow&gt;edge[pr][u]) flow=edge[pr][u];            u=pr;            pr=pre[u];        &#125;        sum+=flow;        u=n;        pr=pre[u];        while(pr!=-1)&#123;            edge[pr][u]-=flow;            edge[u][pr]+=flow;            u=pr;            pr=pre[u];        &#125;<pre><code>    memset(vis,0,sizeof(vis));    for(int i=0;i&amp;lt;205;i++) pre[i]=-1;&#125;return sum;</code></pre><p>}<br>int main(){<br>while(std::cin&gt;&gt;m&gt;&gt;n){<br>memset(edge,0,sizeof(edge));<br>for(int i=1;i&lt;=m;i++){<br>int u,v,w;<br>std::cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>edge[u][v]+=w;<br>}<br>std::cout&lt;&lt;ek()&lt;&lt;std::endl;<br>}<br>return 0;<br>}<br></code></pre></p><ul><li>Extended Euclidean 扩展欧几里得</li></ul><pre><code class='language-cpp' lang='cpp'>#include &lt;iostream&gt;int exgcd(int a,int b,int &amp; x,int &amp; y)&#123;    if(!b)&#123;        x=1;        y=0;        return a;    &#125;    int r=exgcd(b,a%b,x,y);    int tmp=x;    x=y;    y=b*tmp-a/b*b*y;    return r;&#125;int main()&#123;    int a,b;    int x,y;    std::cin&gt;&gt;a&gt;&gt;b;    int r=exgcd(a,b,x,y);    std::cout&lt;&lt;r&lt;&lt;std::endl;    std::cout&lt;&lt;x&lt;&lt;std::endl;    std::cout&lt;&lt;y&lt;&lt;std::endl;    return 0;&#125;</code></pre><ul><li>Ford-Fulkerson 模板题 poj1273</li></ul><pre><code class='language-cpp' lang='cpp'>#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;int n;int m;int edge[205][205];int vis[205];int dfs(int vnum,int flow)&#123;    vis[vnum]=1;    vis[vnum]=1;    if(vnum==n) return flow;    for(int i=1;i&lt;=n;i++)&#123;        if(!vis[i]&amp;&amp;edge[vnum][i]&gt;0)&#123;            int k=dfs(i,flow&gt;edge[vnum][i]?edge[vnum][i]:flow);            if(k&gt;0)&#123;                edge[vnum][i]-=k;                edge[i][vnum ]+=k;                return k;            &#125;        &#125;    &#125;    return 0;&#125;int ff()&#123;    int sum=0;    int flow;    memset(vis,0,sizeof(vis));    while(flow=dfs(1,0x3f3f3f3f))&#123;        memset(vis,0,sizeof(vis));        sum+=flow;<pre><code>&#125;return sum;</code></pre><p>}<br>int main(){<br>while(std::cin&gt;&gt;m&gt;&gt;n){<br>memset(edge,0,sizeof(edge));<br>for(int i=1;i&lt;=m;i++){<br>int u,v,w;<br>std::cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>edge[u][v]+=w;<br>}<br>std::cout&lt;&lt;ff()&lt;&lt;std::endl;<br>}<br>return 0;<br>}<br></code></pre></p><ul><li>kruskal 模板题 poj1258</li></ul><pre><code class='language-cpp' lang='cpp'>#include &lt;iostream&gt;#include &lt;queue&gt;int n;int adjamatrix[200][200];class mycmp&#123;public:    bool operator()(std::pair&lt;int, int&gt; a, std::pair&lt;int, int&gt; b)    &#123;        if (a.second &gt;= b.second)            return true;        else            return false;    &#125;&#125;;bool vis[200];struct edge&#123;    int u;    int v;    int w;    bool operator&lt;(const struct edge &amp;tmp) const    &#123;        if (w &lt; tmp.w)            return true;        else            return false;    &#125;    edge(int _u, int _v, int _w) : u(_u), v(_v), w(_w) &#123;&#125;    edge() &#123;&#125;&#125;;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int fa[200];int count[200];int find(int x)&#123;    return fa[x] == -1 ? x : fa[x] = find(fa[x]);&#125;void join(int x, int y)&#123;    int rootx = find(x);    int rooty = find(y);    if (count[rootx] &gt; count[rooty])    &#123;        fa[rooty] = rootx;        count[rootx] = (count[rooty] + 1 &gt; count[rootx] ? count[rooty] + 1 : count[rootx]);    &#125;    else    &#123;        fa[rootx] = rooty;        count[rooty] = (count[rootx] + 1 &gt; count[rooty] ? count[rootx] + 1 : count[rooty]);    &#125;&#125;bool ask(int x, int y)&#123;    return find(x) == find(y);&#125;int kruskal()&#123;    int sum = 0;    memset(fa, -1, sizeof(fa));    memset(count, 0, sizeof(count));    std::vector&lt;edge&gt; myedges;    for (int i = 1; i &lt;= n; i++)        for (int j = i + 1; j &lt;= n; j++)        &#123;            if (adjamatrix[i][j] &gt; 0)                myedges.push_back(edge(i, j, adjamatrix[i][j]));        &#125;    sort(myedges.begin(), myedges.end());    int cnt = 0;    for (std::vector&lt;edge&gt;::iterator it = myedges.begin();         it != myedges.end(); it++)    &#123;        if (!ask(it-&gt;u, it-&gt;v))        &#123;            sum += it-&gt;w;            join(it-&gt;u, it-&gt;v);            cnt++;        &#125;        if (cnt == n - 1)            return sum;    &#125;    return sum;&#125;int main()&#123;    while (std::cin &gt;&gt; n)    &#123;        for (int i = 1; i &lt;= n; i++)            for (int j = 1; j &lt;= n; j++)                std::cin &gt;&gt; adjamatrix[i][j];        std::cout &lt;&lt; kruskal() &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><ul><li>prim 模板题 poj1258</li></ul><pre><code class='language-cpp' lang='cpp'>#include &lt;iostream&gt;#include &lt;queue&gt;int n;int adjamatrix[200][200];class mycmp&#123;public:    bool operator()(std::pair&lt;int,int&gt; a,std::pair&lt;int,int&gt; b)&#123;        if(a.second&gt;=b.second) return true;        else return false;      &#125;&#125;;bool vis[200];struct edge&#123;    int u;    int v;    int w;    bool operator &lt;(const struct edge&amp; tmp) const&#123;        if(w&gt;tmp.w) return true;        else return false;    &#125;    edge(int _u,int _v,int _w):u(_u),v(_v),w(_w)&#123;&#125;    edge()&#123;&#125;&#125;;int dis[200];#include &lt;cstdlib&gt;#include &lt;cstring&gt;int prim(int vnum)&#123;    int sum=0;    memset(vis,0,sizeof(vis));    memset(dis,0x3f,sizeof(dis));    std::priority_queue&lt;edge&gt; Q;    Q.push(edge(vnum,vnum,0));    while(!Q.empty())&#123;        edge tmp;        int found=0;        while(!Q.empty())&#123;            tmp=Q.top();            Q.pop();            if(!vis[tmp.v])&#123;                found=1;                break;            &#125;        &#125;        if(found==0) return sum;        vis[tmp.v]=true;        sum+=tmp.w;        for(int i=1;i&lt;=n;i++)&#123;            if(!vis[i]&amp;&amp;adjamatrix[tmp.v][i]&gt;0)&#123;                if(adjamatrix[tmp.v][i]&lt;dis[i])&#123;                    dis[i]=adjamatrix[tmp.v][i];                    Q.push(edge(tmp.v,i,dis[i]));                &#125;            &#125;        &#125;    &#125;    return sum;&#125;int main()&#123;    while(std::cin&gt;&gt;n)&#123;        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)                std::cin&gt;&gt;adjamatrix[i][j];        std::cout&lt;&lt;prim(1)&lt;&lt;std::endl;    &#125;    return 0;&#125;</code></pre><ul><li>spfa 模板题 洛谷P3371</li></ul><pre><code class='language-c++' lang='c++'>#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#define INF 0x3f#include &lt;queue&gt;int dis[10010];struct edge&#123;    int v;    int w;    int to;    int next;&#125;;//struct edge myedges[500100];struct edgenode&#123;    int u;    int v;    int w;    struct edgenode* next;&#125;;struct edgenode* adjatable[10010];int n,m,s;void addedge()&#123;    int u,v,w;    std::cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;    edgenode* tmp=adjatable[u];    edgenode* p=new edgenode;    p-&gt;u=u;    p-&gt;v=v;    p-&gt;w=w;    p-&gt;next=tmp;    adjatable[u]=p;&#125;<p>int count[10010];<br>int vis[10010];<br>void spfa(int s)&#123;<br>std::queue&lt;int&gt; Q;<br>Q.push(s);<br>count[s]++;<br>vis[s]=1;<br>while(!Q.empty())&#123;<br>int u=Q.front();<br>Q.pop();<br>vis[u]=0;<br>for(edgenode* p=adjatable[u];p!=NULL;p=p-&gt;next)&#123;<br>if(dis[p-&gt;v]&gt;dis[u]+p-&gt;w)&#123;<br>dis[p-&gt;v]=dis[u]+p-&gt;w;<br>if(!vis[p-&gt;v])&#123;<br>Q.push(p-&gt;v);<br>count[p-&gt;v]++;<br>vis[p-&gt;v]=1;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>int main()&#123;<br>std::cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br>for(int i=1;i&lt;=n;i++) adjatable[i]=NULL;<br>for(int i=1;i&lt;=m;i++)&#123;<br>addedge();<br>&#125;<br>memset(dis,0x3f,sizeof(dis));<br>dis[s]=0;<br>spfa(s);<br>for(int i=1;i&lt;=n;i++)&#123;<br>if(dis[i]==0x3f3f3f3f) std::cout&lt;&lt;2147483647&lt;&lt;&quot; &quot;;<br>else std::cout&lt;&lt;dis[i]&lt;&lt;&quot; &quot;;<br>&#125;<br>return 0;<br>&#125;<br></code></pre></p><ul><li>拓扑排序 模板题 poj2367</li></ul><pre><code class='language-c++' lang='c++'>#include &lt;iostream&gt;#include &lt;queue&gt;struct edge&#123;    int v;    struct edge* next;&#125;;struct edge* adjatable[110];int n;int cnt[110];void insertedge(int vnum,int tmp)&#123;    struct edge** p;    p=&amp;adjatable[vnum];    while(*p!=NULL) p=&amp;((*p)-&gt;next);    *p=new struct edge;    (*p)-&gt;v=tmp;    (*p)-&gt;next=NULL;    cnt[tmp]++;&#125;void toposort()&#123;    std::queue&lt;int&gt; Q;    int start;    int i=1;    for(;i&lt;=n;i++)&#123;        if(cnt[i]==0) Q.push(i);    &#125;    while(!Q.empty())&#123;        int u=Q.front();        Q.pop();        std::cout&lt;&lt;u&lt;&lt;&quot; &quot;;        for(struct edge* p=adjatable[u];p!=NULL;p=p-&gt;next)&#123;            cnt[p-&gt;v]--;            if(cnt[p-&gt;v]==0) Q.push(p-&gt;v);        &#125;    &#125;&#125;int main()&#123;    std::cin&gt;&gt;n;    for(int vnum=1;vnum&lt;=n;vnum++)&#123;        int tmp;        std::cin&gt;&gt;tmp;        while(tmp!=0)&#123;            insertedge(vnum,tmp);<pre><code>        std::cin&amp;gt;&amp;gt;tmp;    &#125;&#125;toposort();return 0;</code></pre><p>}<br></code></pre></p><p>&nbsp;</p><p>!!!</p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初学git</title>
      <link href="/2020/04/08/2020-04-08-%E5%88%9D%E5%AD%A6git/"/>
      <url>/2020/04/08/2020-04-08-%E5%88%9D%E5%AD%A6git/</url>
      
        <content type="html"><![CDATA[<p>!!!</p><h1 >Git</h1><h2 >notes</h2><ol start='0' ><li><p>git command some-path and git command -- some-path are equivalent in all cases except when some-path could be interpreted as a commit reference. The most common case is a branch that has the same name as a file.</p><p>For example, imagine your repository has a file named master in its root. Then git checkout master would checkout the branch master. But git checkout -- master would check out the file master of the current HEAD and replace the local master file with the version of that revision.</p><p>git语法中--的意义是表示命令本身的结束，也就是说--后面的文字将被强制解释成文件或某个区。</p><p>比如<code>git diff  -- cached readme.txt</code>表示cached会被解释成暂存区。</p><p><code>git diff HEAD -- readme.txt</code>中HEAD只能放在--前，不能放在--后，因为HEAD表示工作区顶的指针，也就是上面英文说的commit reference，如果放在--后面将被解释成文件或某个区，此时这个命令会被理解成比较工作区和缓存区中叫做HEAD和叫做readme.txt的两个文件的区别，由于git diff命令的性质，即使找不到叫做HEAD的文件，git diff命令也不做出反应。</p></li><li><p><code>git log</code>查看commit的历史记录</p><p><code>git log --pretty=oneline</code>单行显示历史记录</p><p><code>git reflog</code>查看执行过的命令的历史记录</p></li><li><p><code>git reset --hard HEAD^</code>使HEAD^的内容覆盖工作区和暂存区，HEAD^也可以换成commit id前几位。</p></li><li><p><code>git diff</code>查看暂存区和工作区的区别</p><p><code>git diff HEAD -- readme.txt</code>查看HEAD即最近一次提交与工作区的区别。</p><p><code>git diff  -- cached readme.txt</code>查看暂存区与工作区的区别。</p><p>（注意HEAD写在--前而cached写在后）</p><p><em><strong>git语法中--的意义是表示命令本身的结束，也就是说--后面的文字将被强制解释成文件或某个区。</strong></em></p><p><em><strong>比如<code>git diff  -- cached readme.txt</code>表示cached会被解释成暂存区。</strong></em></p><p><em><strong><code>git diff HEAD -- readme.txt</code>中HEAD只能放在--前，不能放在--后，因为HEAD表示工作区顶的指针，如果放在--后面将被解释成文件或某个区，此时这个命令会被理解成比较工作区和缓存区中叫做HEAD和叫做readme.txt的两个文件的区别，由于git diff命令的性质，即使找不到叫做HEAD的文件，git diff命令也不做出反应。</strong></em></p></li><li><p><code>git branch dev</code> 创建名为dev的分支</p><p><code>git checkout dev</code>切换到名为dev的分支</p><p><code>git checkout -b dev origin/bulabula</code>从远程叫做bulabula的分支创建名为dev的本地分支并切换到本地dev分支</p></li></ol><h2 >我对pull request协作的理解</h2><ol><li>管理员创建主仓库，称为上游仓库，创建dev分支。</li><li>协作者fork上游仓库，进行开发，一个功能开发结束后，申请pull request合并到上游仓库的dev分支。</li><li>每隔一段时间之后，当管理员处理完当前所有pull request时，通知协作者更新自己的仓库为上游仓库，这个操作可以降低管理员处理pull request的困难程度。（如果管理员处理了当前所有pull request，就可以保证协作者无需处理冲突（因为协作者的仓库已经没有意义），可以直接以上游仓库为准）。</li><li>一段开发结束后，管理员将dev分支合并到master分支。并可以根据需要创建一个release version。</li></ol>!!!]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
